#!/bin/bash

# Enhanced Pentesting Tools Installation Script
# Run with: sudo bash install_pentest_tools.sh

set -euo pipefail  # Exit on error, undefined vars, pipe failures

# Script metadata
SCRIPT_VERSION="2.0.0"
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
INSTALL_REPORT="$SCRIPT_DIR/install_report.txt"

# Configuration
readonly CONFIG_FILE="$SCRIPT_DIR/tools_config.json"

# Counters
TOTAL_TOOLS=0
INSTALLED_TOOLS=0
FAILED_TOOLS=0

# Cleanup function
cleanup() {
    local exit_code=$?
    echo "INFO: Cleaning up temporary files..." >&2
    rm -f /tmp/go.tar.gz 2>/dev/null || true
    rm -rf /tmp/Python-* 2>/dev/null || true
    
    if [ $exit_code -ne 0 ]; then
        echo "ERROR: Script failed with exit code: $exit_code" >&2
    fi
}

trap cleanup EXIT

# Banner
print_banner() {
    cat << "EOF"
╔═══════════════════════════════════════════════════════════╗
║               Pentesting Tools Installer                  ║
║                    Version 1.0.0                          ║
╚═══════════════════════════════════════════════════════════╝
EOF
}

# Check if running as root
check_root() {
    if [ "$EUID" -ne 0 ]; then 
        echo "ERROR: Please run as root or with sudo" >&2
        exit 1
    fi
}

# Get actual user
get_actual_user() {
    ACTUAL_USER=${SUDO_USER:-$USER}
    USER_HOME=$(getent passwd "$ACTUAL_USER" | cut -d: -f6)
    
    if [ -z "$USER_HOME" ] || [ ! -d "$USER_HOME" ]; then
        echo "ERROR: Cannot determine user home directory" >&2
        exit 1
    fi
    
    echo "INFO: Installing for user: $ACTUAL_USER" >&2
    echo "INFO: User home directory: $USER_HOME" >&2
}

# Get shell configuration file
get_shell_config_file() {
    local user_shell
    user_shell=$(getent passwd "$ACTUAL_USER" | cut -d: -f7)
    
    case "$user_shell" in
        */bash)
            echo "$USER_HOME/.bashrc"
            ;;
        */zsh)
            echo "$USER_HOME/.zshrc"
            ;;
        */fish)
            echo "$USER_HOME/.config/fish/config.fish"
            ;;
        *)
            echo "$USER_HOME/.profile" # Default to .profile
            ;;
    esac
}

# Check system requirements
check_requirements() {
    echo "INFO: Checking system requirements..." >&2
    
    # Check disk space
    local available_space=$(df -BG "$SCRIPT_DIR" | awk 'NR==2 {print $4}' | sed 's/G//')
    if [ "$available_space" -lt "$MIN_DISK_SPACE_GB" ]; then
        echo "ERROR: Insufficient disk space. Required: ${MIN_DISK_SPACE_GB}GB, Available: ${available_space}GB" >&2
        exit 1
    fi
    
    # Check required commands
    for cmd in "${REQUIRED_CMDS[@]}"; do
        if ! command -v "$cmd" &>/dev/null; then
            echo "WARNING: $cmd not found. Installing..." >&2
            apt install -y "$cmd" || echo "ERROR: Failed to install $cmd" >&2
        fi
    done
    
    echo "SUCCESS: System requirements check passed" >&2
}

# Load script configuration from JSON
load_configuration() {
    echo "INFO: Loading script configuration..." >&2

    # Helper to read config with default
    read_config() {
        local key=$1
        local default=$2
        local value
        value=$(jq -r "$key // empty" "$CONFIG_FILE")
        if [ -z "$value" ]; then
            echo "WARNING: Config key '$key' not found. Using default: $default" >&2
            echo "$default"
        else
            echo "$value"
        fi
    }

    # Read script config values
    MIN_DISK_SPACE_GB=$(read_config ".script_config.min_disk_space_gb" "5")
    GITHUB_CONFIG_URL=$(read_config ".script_config.github_config_url" "https://raw.githubusercontent.com/yourusername/pentest-installer/main/tools_config.json")
    GO_EXAMPLE_VERSIONS=$(read_config ".script_config.go_info.example_versions" "1.22.7, 1.23.1")
    GO_VERSIONS_URL=$(read_config ".script_config.go_info.versions_url" "https://go.dev/dl/")
    GO_URL_TEMPLATE=$(read_config ".script_config.go_info.download_url_template" "https://go.dev/dl/go<VERSION>.linux-amd64.tar.gz")
    PYTHON_EXAMPLE_VERSIONS=$(read_config ".script_config.python_info.example_versions" "3.11.9, 3.12.4")
    PYTHON_VERSIONS_URL=$(read_config ".script_config.python_info.versions_url" "https://www.python.org/downloads/")
    PYTHON_URL_TEMPLATE=$(read_config ".script_config.python_info.download_url_template" "https://www.python.org/ftp/python/<VERSION>/Python-<VERSION>.tar.xz")
    VENV_PATH_TEMPLATE=$(read_config ".script_config.venv_path" "\$USER_HOME/pentest-venv")

    # Read arrays
    mapfile -t REQUIRED_CMDS < <(jq -r '.script_config.required_cmds[]? // empty' "$CONFIG_FILE" | sed '/^\s*$/d')
    if [ ${#REQUIRED_CMDS[@]} -eq 0 ]; then
        echo "WARNING: Config key '.script_config.required_cmds' not found or empty. Using defaults." >&2
        REQUIRED_CMDS=("wget" "tar" "git")
    fi

    mapfile -t PYTHON_BUILD_DEPS < <(jq -r '.script_config.python_info.build_dependencies[]? // empty' "$CONFIG_FILE" | sed '/^\s*$/d')
    if [ ${#PYTHON_BUILD_DEPS[@]} -eq 0 ]; then
        echo "WARNING: Config key '.script_config.python_info.build_dependencies' not found or empty. Using defaults." >&2
        PYTHON_BUILD_DEPS=(
            build-essential libssl-dev zlib1g-dev libbz2-dev
            libreadline-dev libsqlite3-dev curl libncursesw5-dev
            xz-utils tk-dev libxml2-dev libxmlsec1-dev libffi-dev liblzma-dev
        )
    fi

    echo "SUCCESS: Script configuration loaded" >&2
}

# Install jq if needed
ensure_jq() {
    if ! command -v jq &>/dev/null; then
        echo "INFO: Installing jq for JSON parsing..." >&2
        apt install -y jq || {
            echo "ERROR: Failed to install jq" >&2
            exit 1
        }
    fi
}

# Install pipx if needed
ensure_pipx() {
    if ! command -v pipx &>/dev/null; then
        echo "INFO: Installing pipx for isolated Python tool installation..." >&2
        apt install -y pipx || {
            echo "ERROR: Failed to install pipx" >&2
            exit 1
        }
    fi
    su - "$ACTUAL_USER" -c "pipx ensurepath"
}

# Validate JSON config
validate_config() {
    if [ ! -f "$CONFIG_FILE" ]; then
        echo "ERROR: Configuration file not found: $CONFIG_FILE" >&2
        echo "INFO: Please create a valid 'tools_config.json' file in the script directory." >&2
        exit 1
    fi

    if ! jq empty "$CONFIG_FILE" 2>/dev/null; then
        echo "ERROR: Invalid JSON in configuration file: $CONFIG_FILE" >&2
        echo "INFO: Please fix the JSON syntax. You can validate your JSON at: https://jsonlint.com/" >&2
        exit 1
    fi
    
    echo "SUCCESS: Configuration validated" >&2
}

# Determine Go platform string (e.g., linux-amd64)
get_go_platform_string() {
    local os="linux"
    local arch
    arch=$(uname -m)
    local go_arch
    
    case $arch in
        "x86_64")
            go_arch="amd64"
            ;;
        "aarch64")
            go_arch="arm64"
            ;;
        "armv6l")
            go_arch="armv6l"
            ;;
        "i386" | "i686")
            go_arch="386"
            ;;
        *)
            echo "ERROR: Unsupported architecture for Go: $arch" >&2
            return 1
            ;;
    esac
    
    echo "${os}-${go_arch}"
}

# Safe version input with validation
get_version_input() {
    local software=$1
    local example=$2
    local url=$3
    
    echo -e "
=== $software Installation ===" >&2
    echo -e "Check available versions at: $url" >&2
    echo -e "Example: $example" >&2
    echo -e "Press Enter to skip $software installation" >&2
    
    local version
    read -p "Enter $software version to install: " version
    
    # Sanitize input - only allow dots and alphanumeric
    version=$(echo "$version" | tr -cd '[:alnum:].')
    
    echo "$version"
}

# Install Go with better error handling
install_go() {
    local go_platform
    go_platform=$(get_go_platform_string) || return 1

    local go_version
    go_version=$(get_version_input "Go" "$GO_EXAMPLE_VERSIONS" "$GO_VERSIONS_URL")
    
    if [ -z "$go_version" ]; then
        echo "WARNING: Skipping Go installation" >&2
        return 0
    fi
    
    echo "INFO: Installing Go ${go_version} for platform ${go_platform}..." >&2
    
    # Remove old installation
    if [ -d "/usr/local/go" ]; then
        echo "INFO: Removing old Go installation..." >&2
        rm -rf /usr/local/go
    fi
    
    local go_url_with_version="${GO_URL_TEMPLATE/<VERSION>/$go_version}"
    local go_url="${go_url_with_version/linux-amd64/$go_platform}"
    local go_tmp="/tmp/go.tar.gz"
    
    # Download with retry
    local max_attempts=3
    local attempt=1
    
    while [ $attempt -le $max_attempts ]; do
        echo "INFO: Download attempt $attempt of $max_attempts..." >&2
        
        if wget --timeout=30 --tries=3 -q --show-progress "$go_url" -O "$go_tmp"; then
            break
        fi
        
        attempt=$((attempt + 1))
        
        if [ $attempt -gt $max_attempts ]; then
            echo "ERROR: Failed to download Go after $max_attempts attempts" >&2
            return 1
        fi
        
        sleep 2
    done
    
    # Extract and install
    if tar -C /usr/local -xzf "$go_tmp"; then
        rm "$go_tmp"
        
        # Set up environment
        export PATH=$PATH:/usr/local/go/bin
        export GOPATH=$USER_HOME/go
        export PATH=$PATH:$GOPATH/bin
        
        # Update shell config for actual user
        local shell_config_file
        shell_config_file=$(get_shell_config_file)

        if ! grep -q "/usr/local/go/bin" "$shell_config_file"; then
            {
                echo ''
                echo '# Go Programming Language'
                echo 'export PATH=$PATH:/usr/local/go/bin'
                echo 'export GOPATH=$HOME/go'
                echo 'export PATH=$PATH:$GOPATH/bin'
            } >> "$shell_config_file"
        fi
        
        # Create workspace
        mkdir -p "$USER_HOME/go"/{bin,src,pkg}
        chown -R "$ACTUAL_USER":"$ACTUAL_USER" "$USER_HOME/go"
        
        # Verify installation
        if /usr/local/go/bin/go version; then
            echo "SUCCESS: Go ${go_version} installed successfully" >&2
            return 0
        else
            echo "ERROR: Go installation verification failed" >&2
            return 1
        fi
    else
        echo "ERROR: Failed to extract Go" >&2
        rm -f "$go_tmp"
        return 1
    fi
}

# Install Python with better error handling
install_python() {
    local python_version
    python_version=$(get_version_input "Python" "$PYTHON_EXAMPLE_VERSIONS" "$PYTHON_VERSIONS_URL")
    
    if [ -z "$python_version" ]; then
        echo "INFO: Using system Python" >&2
        apt install -y python3 python3-pip python3-venv python3-dev || {
            echo "ERROR: Failed to install system Python packages" >&2
            return 1
        }
        return 0
    fi
    
    echo "INFO: Installing Python ${python_version}..." >&2
    
    # Install build dependencies
    local deps=("${PYTHON_BUILD_DEPS[@]}")
    
    apt install -y "${deps[@]}" || {
        echo "ERROR: Failed to install Python build dependencies" >&2
        return 1
    }
    
    local python_url="${PYTHON_URL_TEMPLATE/<VERSION>/$python_version}"
    local python_tmp="/tmp/Python-${python_version}.tar.xz"
    
    # Download with retry
    if ! wget --timeout=30 --tries=3 -q --show-progress "$python_url" -O "$python_tmp"; then
        echo "ERROR: Failed to download Python" >&2
        return 1
    fi
    
    # Extract and compile
    cd /tmp || return 1
    tar -xf "Python-${python_version}.tar.xz"
    cd "Python-${python_version}" || return 1
    
    ./configure --enable-optimizations --with-ensurepip=install
    make -j"$(nproc)"
    make altinstall
    
    # Extract major.minor version
    local py_short_version
    py_short_version=$(echo "$python_version" | grep -oP '^\d+\.\d+')
    
    # Create symlinks
    ln -sf "/usr/local/bin/python${py_short_version}" /usr/local/bin/python3
    ln -sf "/usr/local/bin/pip${py_short_version}" /usr/local/bin/pip3
    
    # Cleanup
    cd /tmp || return 1
    rm -rf "Python-${python_version}" "$python_tmp"
    
    # Verify
    if python3 --version && pip3 --version; then
        echo "SUCCESS: Python ${python_version} installed successfully" >&2
        return 0
    else
        echo "ERROR: Python installation verification failed" >&2
        return 1
    fi
}

# Setup virtual environment
setup_venv() {
    echo -e "
=== Python Virtual Environment Setup ===" >&2
    read -p "Create or use a virtual environment for pentesting tools? (y/n): " use_venv

    if [[ ! $use_venv =~ ^[Yy]$ ]]; then
        echo "INFO: Skipping virtual environment usage" >&2
        export USE_VENV=false
        return 0
    fi

    local venv_path
    venv_path=$(eval echo "$VENV_PATH_TEMPLATE")

    if [ -d "$venv_path" ]; then
        read -p "Virtual environment at '$venv_path' already exists. Do you want to recreate it? (y/n): " recreate_venv
        if [[ $recreate_venv =~ ^[Yy]$ ]]; then
            echo "INFO: Removing existing virtual environment." >&2
            rm -rf "$venv_path"
        else
            echo "INFO: Using existing virtual environment." >&2
            # Activate and upgrade pip
            # shellcheck disable=SC1090
            source "$venv_path/bin/activate"
            pip install --upgrade pip setuptools wheel
            export USE_VENV=true
            export VENV_PATH="$venv_path"
            echo "SUCCESS: Virtual environment setup complete" >&2
            return 0
        fi
    fi

    echo "INFO: Creating virtual environment at ${venv_path}..." >&2
    
    if su - "$ACTUAL_USER" -c "python3 -m venv $venv_path"; then
        echo "SUCCESS: Virtual environment created" >&2
        
        # Add alias to shell config
        local shell_config_file
        shell_config_file=$(get_shell_config_file)
        if ! grep -q "pentest-venv" "$shell_config_file"; then
            {
                echo ''
                echo '# Pentesting Virtual Environment'
                echo "alias activate-pentest='source $venv_path/bin/activate'"
            } >> "$shell_config_file"
            echo "SUCCESS: Added 'activate-pentest' alias to $shell_config_file" >&2
        fi
        
        # Activate and upgrade pip
        # shellcheck disable=SC1090
        source "$venv_path/bin/activate"
        pip install --upgrade pip setuptools wheel
        
        export USE_VENV=true
        export VENV_PATH="$venv_path"
        echo "SUCCESS: Virtual environment setup complete" >&2
    else
        echo "ERROR: Failed to create virtual environment" >&2
        export USE_VENV=false
        return 1
    fi
}

# Install tool with verification
install_tool() {
    local tool_name=$1
    local tool_type=$2
    local install_cmd=$3
    local verify_cmd=$4
    local description=$5
    
    TOTAL_TOOLS=$((TOTAL_TOOLS + 1))
    
    # Check if tool is already installed
    local is_installed=false
    if [ -n "$verify_cmd" ]; then
        case $tool_type in
            "go" | "pipx")
                if su - "$ACTUAL_USER" -c "$verify_cmd" &>/dev/null; then
                    is_installed=true
                fi
                ;;
            *)
                if eval "$verify_cmd" &>/dev/null; then
                    is_installed=true
                fi
                ;;
        esac
    fi

    if [ "$is_installed" = true ]; then
        echo "INFO: ✓ $tool_name is already installed. Skipping." >&2
        INSTALLED_TOOLS=$((INSTALLED_TOOLS + 1))
        return 0
    fi
    
    echo "INFO: [$TOTAL_TOOLS] Installing $tool_name - $description" >&2
    
    # Execute installation based on type
    local install_result=0
    
    case $tool_type in
        "go")
            if ! su - "$ACTUAL_USER" -c "export PATH=\$PATH:/usr/local/go/bin && command -v go" &>/dev/null; then
                echo "WARNING: Go not installed. Skipping $tool_name" >&2
                FAILED_TOOLS=$((FAILED_TOOLS + 1))
                return 1
            fi
            su - "$ACTUAL_USER" -c "export PATH=\$PATH:/usr/local/go/bin:\$HOME/go/bin && $install_cmd"
            install_result=${PIPESTATUS[0]}
            ;;
        "pipx")
            su - "$ACTUAL_USER" -c "$install_cmd"
            install_result=${PIPESTATUS[0]}
            ;;
        "pip")
            eval "$install_cmd"
            install_result=${PIPESTATUS[0]}
            ;;
        "apt")
            eval "$install_cmd"
            install_result=${PIPESTATUS[0]}
            ;;
        "custom")
            bash -c "$install_cmd"
            install_result=${PIPESTATUS[0]}
            ;;
        *)
            echo "ERROR: Unknown installation type: $tool_type" >&2
            FAILED_TOOLS=$((FAILED_TOOLS + 1))
            return 1
            ;;
    esac
    
    # Verify installation if verify command provided
    if [ $install_result -eq 0 ] && [ -n "$verify_cmd" ]; then
        sleep 1
        case $tool_type in
            "go" | "pipx")
                if su - "$ACTUAL_USER" -c "$verify_cmd" &>/dev/null; then
                    echo "SUCCESS: ✓ $tool_name installed and verified" >&2
                    INSTALLED_TOOLS=$((INSTALLED_TOOLS + 1))
                    return 0
                else
                    echo "WARNING: ✓ $tool_name installed but verification failed" >&2
                    INSTALLED_TOOLS=$((INSTALLED_TOOLS + 1))
                    return 0
                fi
                ;;
            *)
                if eval "$verify_cmd" &>/dev/null; then
                    echo "SUCCESS: ✓ $tool_name installed and verified" >&2
                    INSTALLED_TOOLS=$((INSTALLED_TOOLS + 1))
                    return 0
                else
                    echo "WARNING: ✓ $tool_name installed but verification failed" >&2
                    INSTALLED_TOOLS=$((INSTALLED_TOOLS + 1))
                    return 0
                fi
                ;;
        esac
    elif [ $install_result -eq 0 ]; then
        echo "SUCCESS: ✓ $tool_name installed successfully" >&2
        INSTALLED_TOOLS=$((INSTALLED_TOOLS + 1))
        return 0
    else
        echo "ERROR: ✗ Failed to install $tool_name" >&2
        FAILED_TOOLS=$((FAILED_TOOLS + 1))
        return 1
    fi
}

# Process tools from config
install_tools_from_config() {
    echo "INFO: Installing tools from configuration..." >&2
    
    local categories
    categories=$(jq -r 'keys[]' "$CONFIG_FILE")
    
    for category in $categories; do
        if [ "$category" = "script_config" ]; then
            continue
        fi

        local category_enabled
        category_enabled=$(jq -r --arg cat "$category" '.[$cat].enabled' "$CONFIG_FILE")
        
        if [ "$category_enabled" != "true" ]; then
            echo "INFO: Skipping category: $category (disabled)" >&2
            continue
        fi
        
        echo -e "
=== Category: $(echo "$category" | tr '_' ' ' | tr '[:lower:]' '[:upper:]') ===" >&2
        
        local tools
        tools=$(jq -r --arg cat "$category" '.[$cat].tools | keys[]' "$CONFIG_FILE")
        
        for tool in $tools; do
            local tool_enabled
            tool_enabled=$(jq -r --arg cat "$category" --arg t "$tool" '.[$cat].tools[$t].enabled' "$CONFIG_FILE")
            
            if [ "$tool_enabled" != "true" ]; then
                echo "INFO: Skipping $tool (disabled)" >&2
                continue
            fi
            
            local tool_type install_cmd verify_cmd description
            tool_type=$(jq -r --arg cat "$category" --arg t "$tool" '.[$cat].tools[$t].type' "$CONFIG_FILE")
            install_cmd=$(jq -r --arg cat "$category" --arg t "$tool" '.[$cat].tools[$t].install_cmd' "$CONFIG_FILE")
            verify_cmd=$(jq -r --arg cat "$category" --arg t "$tool" '.[$cat].tools[$t].verify_cmd // empty' "$CONFIG_FILE")
            description=$(jq -r --arg cat "$category" --arg t "$tool" '.[$cat].tools[$t].description' "$CONFIG_FILE")
            
            install_tool "$tool" "$tool_type" "$install_cmd" "$verify_cmd" "$description" || true
        done
    done
}

# Generate installation report
generate_report() {
    echo "INFO: Generating installation report..." >&2
    
    {
        echo "=========================================="
        echo "Pentesting Tools Installation Report"
        echo "=========================================="
        echo "Date: $(date)"
        echo "User: $ACTUAL_USER"
        echo "Home: $USER_HOME"
        echo ""
        echo "Summary:"
        echo "  Total tools processed: $TOTAL_TOOLS"
        echo "  Successfully installed: $INSTALLED_TOOLS"
        echo "  Failed installations: $FAILED_TOOLS"
        echo ""
        echo "Installed Tools by Category:"
        echo "=========================================="
        
        local categories
        categories=$(jq -r 'keys[]' "$CONFIG_FILE")
        
        for category in $categories; do
            if [ "$category" = "script_config" ]; then
                continue
            fi

            local category_enabled
            category_enabled=$(jq -r --arg cat "$category" '.[$cat].enabled' "$CONFIG_FILE")
            
            if [ "$category_enabled" = "true" ]; then
                echo ""
                echo "Category: $(echo "$category" | tr '_' ' ' | tr '[:lower:]' '[:upper:]')"
                echo "-------------------"
                
                local tools
                tools=$(jq -r --arg cat "$category" '.[$cat].tools | keys[]' "$CONFIG_FILE")
                
                for tool in $tools; do
                    local tool_enabled description
                    tool_enabled=$(jq -r --arg cat "$category" --arg t "$tool" '.[$cat].tools[$t].enabled' "$CONFIG_FILE")
                    description=$(jq -r --arg cat "$category" --arg t "$tool" '.[$cat].tools[$t].description' "$CONFIG_FILE")
                    
                    if [ "$tool_enabled" = "true" ]; then
                        echo "  • $tool: $description"
                    fi
                done
            fi
        done
        
        echo ""
        echo "=========================================="
        echo "Configuration file: $CONFIG_FILE"
    } > "$INSTALL_REPORT"
    
    echo "SUCCESS: Installation report saved to $INSTALL_REPORT" >&2
}

# Main installation flow
main() {
    print_banner
    check_root
    get_actual_user
    ensure_jq
    ensure_pipx
    validate_config
    load_configuration
    check_requirements
    
    # Update system
    echo "INFO: Updating system packages..." >&2
    apt update || echo "WARNING: apt update failed" >&2
    
    # Install essential tools
    echo "INFO: Installing build essentials..." >&2
    apt install -y build-essential git curl wget libssl-dev libffi-dev python3-dev || echo "WARNING: Failed to install some build tools" >&2
    
    # Install language runtimes
    install_go || echo "WARNING: Go installation failed or skipped" >&2
    install_python || echo "WARNING: Python installation failed or skipped" >&2
    setup_venv || echo "WARNING: Virtual environment setup failed or skipped" >&2
    
    # Install pentesting tools
    install_tools_from_config
    
    # Fix permissions
    echo "INFO: Fixing permissions..." >&2
    chown -R "$ACTUAL_USER":"$ACTUAL_USER" "$USER_HOME/go" 2>/dev/null || true
    chown -R "$ACTUAL_USER":"$ACTUAL_USER" "$USER_HOME/.bashrc" 2>/dev/null || true
    [ "$USE_VENV" = true ] && chown -R "$ACTUAL_USER":"$ACTUAL_USER" "$VENV_PATH" 2>/dev/null || true
    
    # Deactivate venv
    [ "$USE_VENV" = true ] && deactivate 2>/dev/null || true
    
    # Generate report
    generate_report
    
    # Final summary
    echo -e "
========================================"
    echo -e "Installation Complete!"
    echo -e "========================================"
    echo -e "
Summary:"
    echo -e "  Total tools: $TOTAL_TOOLS"
    echo -e "  Installed: $INSTALLED_TOOLS"
    echo -e "  Failed: $FAILED_TOOLS"
    
    echo -e "
Important: Run this command to update your environment:"
    echo -e "source ~/.bashrc"
    
    if [ "$USE_VENV" = true ]; then
        echo -e "
Virtual Environment:"
        echo -e "  Activate: activate-pentest"
        echo -e "  Deactivate: deactivate"
    fi
    
    echo -e "
Files generated:"
    echo -e "  • Installation report: $INSTALL_REPORT"
    echo -e "  • Configuration: $CONFIG_FILE"
    
    if [ $FAILED_TOOLS -gt 0 ]; then
        echo -e "
⚠ Some tools failed to install. Check the output above for details." >&2
    fi
    
    echo -e "
Configuration Management:"
    echo -e "Edit $CONFIG_FILE to customize your installation"
}

# Run main function
main "$@"
